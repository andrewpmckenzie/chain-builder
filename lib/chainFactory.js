var CallQueue = require('./CallQueue');
var contextFactory = require('./contextFactory');
var curry = require('./curry');

/**
 * @module chainFactory
 * @private
 */

/**
 * @memberof module:chainFactory
 * @function chainFactory
 * @param {MethodMap}          methods        - methods to mix in to the chain
 * @param {ContextMethod[]}    contextMethods - methods to mix into the chain's context
 * @returns {ChainConstructor}
 */
module.exports = function (methods, contextMethods) {
  var Context = contextFactory(contextMethods);

  /**
   * Internal constructor for a Chain. Chains are normally created with a {@link ChainConstructor} generated by {@link module:chainbuilder}.
   *
   * @private
   * @constructor
   * @param {Object}     options
   * @param {?CallQueue} options.callQueue     - the queue of calls to run
   * @param {?*}         options.initialResult - start execution of the chain immediately with this as the initial result
   */
  var Chain = function (options) {
    options = options || {};

    // queue of calls to be processed
    this._callQueue = options.callQueue || this._newCallQueue();

    if (options.initialResult !== undefined) {
      this._callQueue.start(options.initialResult);
    }
  };

  /**
   * @returns {CallQueue}
   * @private
   */
  Chain.prototype._newCallQueue = function (levelsUp) {
    return new CallQueue({
      methods: this._methods,
      Chain: Chain,
      Context: Context
    });
  };

  /**
   * Add a method call to the queue.
   *
   * @param {String} methodName - name of the method to call
   * @param {...*}   args       - arguments to curry
   * @returns {Chain}
   * @private
   */
  Chain.prototype._addToChain = function (methodName/*, ... */) {
    var method = this._methods[ methodName ];
    if (!method) throw new Error('Method not present on object: ' + methodName);

    var args = Array.prototype.slice.call(arguments, 1);
    var interceptError = !!method.$interceptErrors;

    this._callQueue.add(methodName, args, !interceptError);

    return this;
  };

  /**
   * @type {MethodCallback[]}
   * @private
   */
  Chain.prototype._methods = methods;

  /**
   * Create a copy of this chain.
   *
   * Adding to the call queue of the copy will not affect the call queue of the original.
   *
   * @memberof Chain
   * @returns {Chain}
   */
  Chain.prototype.clone = function () {
    return new Chain({ callQueue: this._callQueue.clone() });
  };

  /**
   * Execute the chain.
   *
   * @memberof Chain
   * @param {?*}                    initialResult  - available to the first method in the chain via `this.previousResult()`.
   * @param {?Chain.ResultCallback} cb             - called when the chain is finished executing.
   * @returns {undefined}
   */
  Chain.prototype.run = function (initialResult, cb) {
    if (!cb) {
      cb = initialResult;
      initialResult = null;
    }
    this._callQueue.clone().start(initialResult, cb);
  };

  /**
   * Provide a string representation of the Chain for logging.
   *
   * @returns {string}
   * @ignore
   */
  Chain.prototype.toLogString = function () { return 'Chain(links=' + this._callQueue._queue.length + ')' };

  // Add provided methods to prototype
  for (var methodName in methods) {
    if (!methods.hasOwnProperty(methodName)) continue;

    if (Chain.prototype[methodName]) throw new Error('Method name already used: ' + methodName);

    Chain.prototype[methodName] = curry(Chain.prototype._addToChain, methodName);
  }

  return Chain;
};
