var CallQueue = require('./CallQueue');
var contextFactory = require('./contextFactory');
var curry = require('./curry');

/**
 * @module chainFactory
 * @private
 */

/**
 * @memberof module:chainFactory
 * @function chainFactory
 * @param {MethodMap}          methods        - methods to mix in to the chain
 * @param {ContextMethod[]}    contextMethods - methods to mix into the chain's context
 * @returns {ChainConstructor}
 */
module.exports = function (methods, contextMethods) {
  var Context = contextFactory(contextMethods);

  /**
   * Internal constructor for a Chain. Chains are normally created with a {@link ChainConstructor} generated by {@link module:chainbuilder}.
   *
   * @private
   * @constructor
   * @param {Object}     options
   * @param {?Number}    options.depth         - how deep is this chain embedded in other chains (for logging)
   * @param {?CallQueue} options.callQueue     - the queue of calls to run
   * @param {?*}         options.initialResult - start execution of the chain immediately with this as the initial result
   */
  var Chain = function (options) {
    options = options || {};

    this._depth = options.depth || 0;
    this._callQueueStack = [];
    this._callQueueNameStack = [];

    // queue of calls to be processed
    this._callQueue = options.callQueue || this._newCallQueue();

    if (options.initialResult !== undefined) {
      this._callQueue.start(options.initialResult);
    }
  };

  /**
   * @param   {Number} levelsUp - increase the depth of the CallQueue by this amount (typically 0 or 1).
   * @returns {CallQueue}
   * @private
   */
  Chain.prototype._newCallQueue = function (levelsUp) {
    return new CallQueue({
      methods: this._methods,
      onBeginSubchain: this._beginSubchain.bind(this),
      onEndSubchain: this._endSubchain.bind(this),
      depth: this._depth + (levelsUp || 0),
      Chain: Chain,
      Context: Context
    });
  };

  /**
   * Start a new subchain.
   *
   * @param {String} subchainName - the name of the subchain
   * @private
   */
  Chain.prototype._beginSubchain = function (subchainName) {
    this._callQueueStack.push(this._callQueue);
    this._callQueueNameStack.push(subchainName);
    this._callQueue = this._newCallQueue(1);
  };

  /**
   * Complete a subchain.
   *
   * @param {String} subchainName - the name of the subchain
   * @private
   */
  Chain.prototype._endSubchain = function (subchainName) {
    if (this._callQueueStack === 0) throw new Error('Attempting to close a "' + subchainName + '" block when none is open.');

    var currentSubchainName = this._callQueueNameStack.pop();
    if (currentSubchainName !== subchainName) throw new Error('Attempting to close a "' + subchainName + '" block when there\'s an open "' + currentSubchainName + '" block.' );

    var subqueue = this._callQueue;
    this._callQueue = this._callQueueStack.pop();
    return new Chain({ callQueue: subqueue });
  };

  /**
   * Add a method call to the queue.
   *
   * @param {String} methodName - name of the method to call
   * @param {...*}   args       - arguments to curry
   * @returns {Chain}
   * @private
   */
  Chain.prototype._addToChain = function (methodName/*, ... */) {
    var method = this._methods[ methodName ];
    if (!method) throw new Error('Method not present on object: ' + methodName);

    var args = Array.prototype.slice.call(arguments, 1);
    var interceptError = !!method.$interceptErrors;

    if (method.$endSubchain) {
      var subchain = this._endSubchain(method.$endSubchain);
      args.unshift(subchain);
    }

    this._callQueue.add(methodName, args, !interceptError);

    if (method.$beginSubchain) {
      this._beginSubchain(method.$beginSubchain);
    }

    return this;
  };

  /**
   * @type {MethodCallback[]}
   * @private
   */
  Chain.prototype._methods = methods;

  /**
   * Create a copy of this chain.
   *
   * Adding to the call queue of the copy will not affect the call queue of the original.
   *
   * @memberof Chain
   * @returns {Chain}
   */
  Chain.prototype.clone = function () {
    if (this._callQueueStack.length > 0) throw new Error('Cannot clone while there are open blocks.');
    return new Chain({ callQueue: this._callQueue.clone() });
  };

  /**
   * Execute the chain.
   *
   * @memberof Chain
   * @param {?*}                    initialResult  - available to the first method in the chain via `this.previousResult()`.
   * @param {?Chain.ResultCallback} cb             - called when the chain is finished executing.
   * @returns {undefined}
   */
  Chain.prototype.run = function (initialResult, cb) {
    if (this._callQueueStack.length > 0) throw new Error('Cannot run while there are open blocks: ' + this._callQueueNameStack.join(','));
    if (!cb) {
      cb = initialResult;
      initialResult = null;
    }
    this._callQueue.clone().start(initialResult, cb);
  };

  /**
   * Provide a string representation of the Chain for logging.
   *
   * @returns {string}
   * @ignore
   */
  Chain.prototype.toLogString = function () { return 'Chain(links=' + this._callQueue._queue.length + ')' };

  // Add provided methods to prototype
  for (var methodName in methods) {
    if (!methods.hasOwnProperty(methodName)) continue;

    if (Chain.prototype[methodName]) throw new Error('Method name already used: ' + methodName);

    Chain.prototype[methodName] = curry(Chain.prototype._addToChain, methodName);
  }

  return Chain;
};
